\documentclass[a4paper]{article}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epigraph}
\usepackage{pgf}
\usepackage{graphicx}
\usepackage{framed}
\usepackage{amsthm}

% input encoding and font enconding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% biblatex setup
\usepackage[backend=biber,
            style=ieee,
            ]{biblatex}
\addbibresource{bibliography.bib}

% context-sensitive quotes package (?)
\usepackage{csquotes}

% font packages
\usepackage{lmodern}
\usepackage{courierten}

% font setup
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\rmdefault}{cmr}

% custom commands for font usage
% \newcommand{\usefontcm}{\familydefault{cmr}\selectfont}

% hyperref package; convention to always add as last package
\usepackage{hyperref}


% adding text spacing in math mode
\renewcommand*{\textnormal}[1]{\text{ #1 }}

% epigraph package settings
\renewcommand{\epigraphflush}{center}
\setlength{\epigraphwidth}{0.75\textwidth}

% removing highlighting of hyperref links
\hypersetup{pdfborder={0 0 0}}

% Plans: Add experiment data to CSV file, parse CSV and create plots.
% Organize file structure (mainly the py files) and publish to repo.
% Research python 'signal' module, make program stop running after a certain amount of time (e.g. 1 minute?)
% Meh: research python 'logging' module, log sorting algorithm progress
% Input data: 4 to 8 byte signed integers, 4-8byte strings, Unicode characters?

\begin{document}

% TITLE PAGE

    \begin{figure}[t]
        \centering
        \includegraphics[width=8cm]{../assets/UVT_logo_en.png}
    \end{figure}

    \begin{center}
        {\fontfamily{cmr}\selectfont

            {\hypertarget{title}{\huge 
                The algorithm showdown: \\
                A \textbf{theoretical} and \textbf{experimental} comparison of popular sorting algorithms
                }
            }

            \vspace{0.5cm}

            {\Large Raul-Andrei Ariton \\ Department of Computer Science, \\ West University of Timișoara}
        }

        \vspace{0.25cm}

        {\large \href{mailto:raul.ariton05@e-uvt.ro}{\texttt{raul.ariton05@e-uvt.ro}}}
        
    \end{center}

    \vspace{0.25cm}

    \begin{abstract}
        
        Perhaps one of the most fundamental problems in Computer Science, algorithms that solve the problem of sorting are critical to anyone starting out in the area of Algorithms and Data Structures. They are a showcase of clever algorithmic thinking, as well as an application of common algorithm design techniques.

        This research paper compares popular sorting algorithms such as 
        Bubble Sort, Selection Sort, QuickSort,
        %  Heap Sort, 
        and more, using a theoretical as well as a practical, experimental approach.

        Generally, this paper aims to emphasize that there is no ``superior'' sorting algorithm and that each algorithm has its ideal use case, its strengths and weaknesses. Such weaknesses are showcased, and moreover potential optimizations are discussed, in order to ensure algorithm reliability and stability.

        The findings of this paper aim to guide developers, researchers in choosing the algorithm that suits their sorting problem the best.
        
    \end{abstract}
% END TITLE PAGE

    \newpage

    \tableofcontents

    \newpage
    \part{Introduction}
    \section{An everyday sorting problem}
        Consider the following problem:

        \begin{framed}
            {\fontfamily{cmr}\selectfont
            I have a T-shirt for every day of the week (\emph{\(7\) T-shirts}). I decide to wash them all together at the end of the week. 
            
            After they are all washed and dried, I have to put them back in the closet, in the order I am going to wear them (\emph{ascending order of numbers}). 
            
            How can I do this in the \textbf{shortest time possible}, and using the \textbf{least amount of space} possible (\emph{separating groups of T-shirts as little as possible})?
            \vspace*{1em}

            \noindent \textbf{Note.} \textit{For analogy purposes, assume each T-shirt is laid facing-down, and its number can only be seen if picked up. Only one T-shirt can be picked up at a time.}
            }
        \end{framed}

        \noindent The above is an over-simplified example of a \textbf{sorting problem} that an average person might encounter in everyday life.

        In short, the sorting problem in computer science consists of organizing a collection of data, called \emph{keys}, into a specific order (\emph{in our case, in ascending order of numbers}).

        \subsection{The importance of sorting}

            Although at first, sorting might seem like a rare problem one might encounter, wether that be in their everyday life or in software development, there is a reason why it is considered the most fundamental problem in the study of algorithms:

            \begin{itemize}
                \item A
                    Sorting is essential in data analysis, as it helps data scientists/analysts organize, find, visualize and understand data in order to make better, reliable decisions
                \item 
                    Many algorithms use sorting as a key          subroutine, or require a sorted data structure as a prerequisite\supercite{clrs_algorithms}.

                    Referring back to the T-shirt problem, suppose one has to search for the T-shirt number \(x, \ 1 \leq x \leq 7\). Assuming the T-shirts are \textbf{sorted} in increasing order, the \href{https://en.wikipedia.org/wiki/Binary_search_algorithm}{Binary Search} algorithm can be applied, with a worst-case scenario runtime of \(O(\log n) \overset{n = 7 \textnormal{(days)}}{=} O(\log 7) \approx O(3)\), which means the search would require at most 3 steps, depending on the value of \(x\).

                    
                \item Since there is no ``superior'' sorting algorithm that can be used and relied on for any and every sorting problem, knowledge of various sorting algorithms and their respective strengths and weaknesses is critical. 
                
                The fastest sorting algorithm for a specific situation depends on many factors, such as the input data type (\emph{key type}), how the data is stored (the \emph{record}), prior knowledge about the data to be sorted\supercite{clrs_algorithms}, and many more.

                \item The vast catalog of sorting algorithms that exist 
                    today employ a rich set of techniques. 
                    In fact, teaching various sorting algorithms also teaches various algorithm design techniques, along with algorithmic thinking.
                    
                    This paper will discuss such design techniques in each case.
            \end{itemize}

        \subsection{Possible solutions}

            \begin{itemize}
                \item
                    One solution is the so-called ``brute-force'' approach: \newline
                    Throw the pile of \(n = 7\) T-shirts in the air, and lay them out, eventually checking if they are sorted. 
                    
                    \noindent If they are sorted, celebrate. 
                    
                    \noindent If not, repeat until they become sorted.

                    % pseudocode style typesetting?

                    This sorting algorithm is called \href{https://en.wikipedia.org/wiki/Bogosort}{\textbf{BogoSort}}, and has an average-case complexity of \(\Theta(n \times n!)\)\supercite{sorting_the_slow_way}, which in the case of our example evaluates to \(\Theta(n \times n!) = \Theta(7 \times 7!) = \Theta(7 \times 5040) = \Theta(35280)\).
                    Which means, one would have to repeat the process on average \(35280\) times. \emph{Not to mention the fact that this process could repeat forever.}

                \item 
                    Another solution is laying out each T-shirt, and swapping each T-shirt with its neighbouring one, repeating the process \(n = 7\) times, until the T-shirts are laid out in ascending order.

                    This sorting algorithm is called \textbf{Bubble Sort}, and it will be explored in further detail later in this paper.
                    % add reference to bubble sort in paper.
                    It has a worst-case time complexity of \(O(n^2)\)% add reference to bubble sort theoretical analysis in paper.
                    , which in the case of our example evaluates to \(O(n^2) = O(7^2) = O(49)\).
                    Which means one would have to repeat the process at most \(49\) times.

            \end{itemize}

            \noindent As expected, these approaches do not ensure the shortest execution time.
            \vspace*{1em}
            
            \paragraph{Transitioning to formal definitions.} Moving from a simple analogy to more complex, formal definitions and processes, we shall explore more time-efficient solutions to our sorting problem, as well as experimenting with larger, more complex types of inputs to be sorted.
        
    \newpage
    \section*{Declaration of originality}
        I, Raul-Andrei Ariton, under the West University of Timișoara hereby present my research paper, titled \hyperlink{title}{\emph{The algorithm showdown: A theoretical and experimental comparison of popular sorting algorithms}}, and I declare that it is a product of my own research and investigation. Wherever deemed necessary, and to the best of my abilities, I have referenced and thus acknowledged the sources where I have derived ideas or extracts. Furthermore, I state that this paper has not been submitted anywhere else for publication.
        \vspace*{1em}

        The experiment process is done completely by myself, thus the experiment results are all original and not fabricated. Moreover, the plots, that visually represent my experiment results are all created using my code and mine only.

    \newpage
    \section{Reading Instructions}
    
        For the rest of the paper, the formal definition of the sorting problem will be presented, as well as various solutions of this problem (sorting algorithms). 
        
        For each solution, a short theoretical analysis will be conducted, proving its corectness, termination as well as its execution time complexity.

        Afterwards, a general (\emph{pseudocode}) implementation of the solution will be presented.

        Throughout this paper, solutions will be categorized based off of the techniques they use, and for each such category, all of its solutions will be compared under various test cases (\emph{input data types}), to then declare the most performant solution in that category. 
        
        Finally, all ``winner'' solutions of their respective category will be compared, in order to declare a ``final winner'', i.e. solution which generally performs well in any test case.
    
    \newpage
    \section{The problem of sorting in Computer Science}

        \noindent Consider the following problem:

        \begin{framed}
            {\fontfamily{cmr}\selectfont
            \noindent\textbf{Input:} A sequence of $n$ numbers $\langle a_1 , a_2 , \dots , a_n  \rangle$ 
            \vspace*{0.25em} \\
            \textbf{Output:} A permutation (reordering) $\langle a_1^{'}, a_2^{'} , \dots , a_n^{'}\rangle$ of the inputs
            such that
             
            \[a_1^{'} \preceq a_2^{'} \preceq \dots \preceq a_n^{'}\]
        
            \noindent where $\preceq$ is an order
            % \footnote{irreflexive, transitive and antisymmetric} 
            relation (predicate).
            }

        \end{framed}
    \noindent The above describes the sorting problem in Computer Science\supercite{clrs_algorithms}.

    \subsection{Elements of  a sorting problem}
        A sorting problem may consist of\supercite{clrs_algorithms}:
        \begin{itemize}
            \item The \textbf{record}, the collection of data to be sorted.
                    
                \textit{In the theoretical analyses of algorithms, the record is considered to be an array.
                In the implementations and experiments, however, Python lists will be used, which are essentially \emph{dynamic arrays}, which grow along with the insertion of elements.}

            \item The \textbf{key}, the value to be sorted, or in other words, the value that determines the reordering of the record.
            
                \textit{In the theoretical analyses of algorithms, the keys are considered to be numerical values (numbers).
                In the experiments, however, various types of keys will be used.}

            \item The \textbf{satellite data}, which are values carried around with the key,
                but which do not determine the reordering of the record. In practice, when
                reordering keys, a sorting algorithm must permute the satellite data along with
                its respective key.

                \textit{The algorithm implementations in this paper are not implemented for such cases. Entries in the record consist purely of keys (the values that will be permuted)}

        \end{itemize}

    \subsection{Solutions to the sorting problem}

        The sorting problem in Computer Science is solved using sorting algorithms. Generally, an algorithm must be:
        \begin{itemize}
            \item Correct, which means:
                \begin{itemize}
                    \item its input satisfies the problem's preconditions\footnote{conditions that the input data of the problem must satisfy.}\supercite{the_skiena_2010}
                    \item it terminates after a finite number of steps
                    \item its output satisfies the problem's postconditions\footnote{required properties of the problem's output.}\supercite{the_skiena_2010}
                \end{itemize}
            \item Efficient, i.e. it needs to utilize a \emph{reasonable} amount of resources (\emph{time, space in memory}).
        \end{itemize}

        \paragraph{A note on space complexity.} This paper focuses mainly on comparing algorithms based on their execution time rather than the space they use in memory.

        This is rather a personal choice, as machine memory as a resouce is getting more and more affordable as a result of many impressive advances in the area of Computer Architecture. 
        
        However, time is a much more important resource to account for when analyzing and implementing algorithms.
        
        Wherever possible, mentions of the algorithm's space complexity will be made.
        \vspace*{2em}

        \noindent Now that the formalities have been defined and explained, we shall move on to categorizing sorting algorithms and analyzing them one-by-one.

    % \section{The "superior" sorting algorithm}
    %     There is no such thing as “the best sorting algorithm”. 
    %     Many might say Quick Sort is the one, with a complexity of $O(n\log n)$
    %     (\textit{We will notice in our experiments that in some cases Quick Sort is not so reliable}).
        
    %     \noindent However, the best sorting algorithm depends on the situation. 
    %     Not all sorting problems are the same, therefore there isn't a “one-for-all” algorithm 
    %     which should be used each time.

    %     \begin{itemize}
    %         \item Bubble Sort is used by some TV providers 
    %             in order to sort channels based on audience viewing time.
    %         \item Merge sort is used on databases, because of the large sets of data, 
    %             that are too large to be loaded into memory as a whole.
    %         \item Quick sort is used to \textit{quickly} sort sports scores in real-time.
    %     \end{itemize}
        
    \newpage
    \part{The Algorithms}

        % This section aims to describe the main idea each sorting algorithm individually, its pseudocode implementation as well as its implementation in the \textbf{Python} programming language.

        % Pseudocode of the algorithms, analysis of the algorithm
        % design technique, corectness analysis (???), 
        % complexity analysis, sorting algorithm stability and how
        % an unstable sorting algorithm could mess things up

        % We can think of what we explained so far as a scientifical hypothesis.
        % A hypothesis becomes a fact when it remains true through multiple
        % experiments.
        % So, does this theory hold in practice?

        \setcounter{section}{0}
        \section{Classification of sorting algorithms}

            Below follow some terminologies that not only allow better organization of this paper, but also serve as a guide to researchers as well as learners to differentiate between the different types of sorting algorithms. Special acknowledgments to \cite{ali2021sorting} for the extensive coverage on this topic.

            A sorting algorithm can be categorized based on the following criteria:
            \begin{itemize}
                \item Comparison sorting or Non-Comparison Sorting
                    \begin{itemize}
                        \item Comparison-based algorithms sort using a comparison operator between two elements in the array, which is defined using a function (\emph{either built-in or user-defined}). The best known time complexity of a comparison-based sorting algorithm is \(O(n \log n)\).
                        \item Algorithms which are not based on comparison of elements sort based on assumptions about the input data, thus can only be applied to input data which satisfy specific conditions. In a very ideal case, a Non-Comparison sorting algorithm can achieve a complexity of \(O(n)\).
                    \end{itemize} 
                        % \begin{remark}
                        %     One may not take this information for granted, because, as mentioned, to achieve such an execution time, the array values need to satisfy very specific conditions.
                        % \end{remark}
                    
                    
                \item Stability
                    In the case where two values in the array are equal, their relative order, i.e. the order in which they appear in the original array order, must be preserved to consider a sorting algorithm \emph{stable}.

                    If this relative order is not preserved, the algorithm is unstable, i.e. not stable

                    Few sorting algorithms are \emph{naturally} stable, however most of the time any unstable sorting algorithm can be modified in order to become stable\supercite{the_skiena_2010}.

                \item In-place or Out-of-place Sorting
                    \begin{itemize}
                        \item An algorithm sorts in-place if only a constant number of elements of the input array get stored outside the array\supercite{clrs_algorithms}. In practice, no copies of the array values are made outside of it, and the sorting is performed directly on the original array in memory.
                        \item An algorithm sorts out-of-place if it makes copies (also called \emph{buffers}) of the array, or parts of it, and performs the sorting process on those copies, and not directly on the original array in memory.
                    \end{itemize}
            \end{itemize}
        
        \newpage
        \section{In-place comparison-based sorting algorithms}

            \subsection{Bubble Sort}
                % \textbf{Bubble Sort} is an in-place, comparison-based sorting algorithm.
                \paragraph{Main idea.}
                The array to be sorted is traversed repeatedly, 
                adjacent elements are compared and swapped if they are out of order. The traversal stops when during a 
                traversal no swapping has taken place (\textit{i.e. when the array becomes sorted}).
                \subsubsection*{Corectness and complexity analysis}
                \subsubsection*{Implementation}

            \subsection{Insertion Sort}
                % \textbf{Insertion Sort} is an in-place, comparison based algorithm.
                \paragraph{Main idea.}
                The algorithm starts sorting the elements starting 
                from the right-most element to the left-most element.

                Starting with the \textit{second 
                element} in the array (\textbf{we consider
                the first element as sorted}), we
                compare it with every previous element
                (\textit{for example, in the first instance, the second element gets
                compared with the first}) and
                proceed moving leftwards in the array, until we
                find an element such that if we place the current element
                after it, the sorting order will hold.
                \subsubsection*{Corectness and complexity analysis}
                \subsubsection*{Implementation}
            
            \subsection{Selection Sort}
                % \textbf{Selection Sort} is an in-place, comparison based algorithm.
                \paragraph{Main idea.}
                Starting with the first element in the array, for each element at position
                \verb|i| we search for a \textbf{minimum value} in the sub-array
                \verb|x[i...n]|, where \verb|n| is the size of the array.

                If the minimum value found in the sub-array is less than the
                element at position \verb|i|, we swap the element at position \verb|i|
                with that minimum value
                (\textit{hence} \verb|IF arr[x]<arr[i] THEN swap(x[i],x[k])|).

                This process is repeated \verb|n-1| times, because after all
                the iterations, the last element will be \textbf{naturally sorted}
                (\textit{hence} \verb|FOR i := 1 , n-1 DO|).

                \subsubsection*{Corectness and complexity analysis}
                \subsubsection*{Implementation}
        
        \newpage
        \section{Not-in-place comparison-based sorting algorithms}
            \subsection{Quick Sort}
            \textbf{Quick Sort} is different from what we've encountered so far. 
            It uses the \textbf{“divide and conquer”} 
            (also known as the “divide and rule”) 
            technique. \textit{Who knew that a policy used in ancient times to maintain power, 
            by great rulers, could be implemented in solving a sorting problem?}
            Additionally, Quick Sort does not sort in place like all sorting algorithms mentioned so far.
            
            \paragraph{Main idea.}
            \subsubsection*{Corectness and complexity analysis}
            \subsubsection*{Implementation}

            \subsection{Merge Sort}
                \paragraph{Main idea.}
                \subsubsection*{Corectness and complexity analysis}
                \subsubsection*{Implementation}
        % \section{Not comparison-based sorting algorithms}
    
    \newpage
    \part{Case Study}
    \setcounter{section}{0}
    \section{Methodology}
    % How measurements were made (how execution time was measured), comparisons made to confirm results, make table with comparison times, etc.
    \section{In-place comparison-based sorting algorithms, compared}
    \section{Not-in-place comparison-based sorting algorithms, compared}
    % \section{Non-comparison based sorting algorithms, compared}
    \section{The ``superior'' sorting algorithm}
            % Hopefully in this section we will reach a conclusion that there is no algorithm which is always "fast", therefore proving that there is no superior sorting algorithm
    
    \newpage
    \part{Conclusions and Ending}
    \setcounter{section}{0}
    \section{Related Work}
        % Cite some related sorting algorithm comparison papers and see that their results are similar to mine. See additional notes on classroom.
    \section{Conclusions and Future Work}

    
    % END CONTENT

    \newpage

    \printbibliography

\end{document}